# Gardens on Rails

## Run the demo

If you received this repository as an archive, unzip the archive containing the code and move the folder to `~/code/$GITHUB_USERNAME`.

Then, switch to the folder and install the dependencies:

```bash
cd ~/code/$GITHUB_USERNAME/gardens-on-rails
bundle install
```

Finally, run the migrations and start the server:

```bash
rails db:migrate db:seed
rails s
```

## Context

Today, you discovered how to handle multi-model apps in Rails. The goal of this livecode is to make sure you are comfortable with the complexity of the framework.

To do this, we‚Äôre going to create an app to create plants associated with a garden.

The actions we want to implement are:

1. As a user I can see one garden's plants
2. As a user I can add a plant in a garden
3. As a user I can delete a plant

Here is a screenshot of what it will look like:

![](https://raw.githubusercontent.com/gabrielecanepa/lewagon/main/camps/1506/gardens-on-rails/public/garden.png)

## Implementation

Let's start a server with:

```bash
rails s
```

### Front-end setup

Following [the documentation](https://getbootstrap.com/docs/5.1/getting-started/introduction/#css), install Bootstrap stylesheets to your Rails app by copy-pasting the link tag in the head of the `application.html.erb` layout:


```erb
<!-- File: app/views/layouts/application.html.erb -->

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
<!-- Place this line before the following helper importing our stylesheets! üëÜ -->
<%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
<!-- [...] -->
```

You can now use any Bootstrap class anywhere in your Rails views üéâ

Let's also install the `simple_form` gem to easily generate forms with Bootstrap classes. Add the following line to your `Gemfile`:

```ruby
# File: Gemfile

# [...]
gem "simple_form"
```

Then run bundler and the generator:

```bash
# Install the new gem
bundle install
# Generate the simple_form config file
rails generate simple_form:install --bootstrap
```

> ‚ö†Ô∏è Remember to always restart your server after installing a new gem!

### Scaffold gardens

To save time, we‚Äôll scaffold gardens.

> ‚ö†Ô∏è You should NOT use this feature when learning Rails!

```bash
rails g scaffold Garden name banner_url
```

Add some quick validations:

```ruby
# File: app/models/garden.rb

class Garden < ApplicationRecord
  validates :name, presence: true, uniqueness: true
  validates :banner_url, presence: true
end
```

And run the migrations:

```bash
rails db:migrate
```

The scaffold has also automatically added the line `resources :gardens` to `config/routes.rb`. To make sure that we land on the garden index page when we visit the root of our app, we can also add a root pointing to `gardens#index`:

```ruby
# File: config/routes.rb

Rails.application.routes.draw do
  root to: 'gardens#index'
  resources :gardens
end
```

### Seeding gardens

We can use this snippet to seed 2 gardens:

```rb
# File: db/seeds.rb

# Destroy all gardens to start from a clean state.
Garden.destroy_all

# Create 2 gardens.

Garden.create!(
  name: "My Little Garden",
  banner_url: "https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/parks-and-plants/garden_1.jpg"
)

Garden.create!(
  name: "My Other Garden",
  banner_url: "https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/parks-and-plants/garden_2.jpg"
)

puts "Created #{Garden.count} gardens!"
```

Run the seed file with:

```bash
rails db:seed
```

Then let's check the website again to see what the scaffold generated. Ugly, right? üßü

### Show a garden

So let‚Äôs start by quickly removing the code generated by the scaffold and adding a banner.

Open [Le Wagon UI Kit](https://uikit.lewagon.com/documentation#banner) (containing some pre-coded components) and replace the content of the show view with the following:

```erb
<!-- File: app/views/gardens/show.html.erb -->

<div class="banner" style="background-image: linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)), url('<%= @garden.banner_url %>');">
  <div class="container">
    <h1><%= @garden.name %></h1>
  </div>
</div>
```

Then add a new CSS file to style this component and make it look nicer:

```bash
# 1. Create a components folder to implement CSS for each component
mkdir app/assets/stylesheets/components
# 2. Create a new file for the banner component
touch app/assets/stylesheets/components/_banner.scss
```

Let's paste the CSS from the UI kit into the newly created stylesheet:

```css
/* File: app/assets/stylesheets/components/_banner.css */

.banner {
  background-size: cover;
  background-position: center;
  padding: 150px 0;
}

.banner h1 {
  margin: 0;
  color: white;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
  font-size: 32px;
  font-weight: bold;
}

.banner p {
  font-size: 20px;
  color: white;
  opacity: .7;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
}
```

You should get the following result:

![](https://raw.githubusercontent.com/gabrielecanepa/lewagon/main/camps/1506/gardens-on-rails/public/garden-banner.png)

Okay that was a good kickstart, time to code the plant model! üå∑

### Add plants

Let‚Äôs generate the plant model with the attributes `garden_id` (a plant **belongs to** a garden), `name`, and `image_url`.

```bash
# To add the reference and generate a garden_id column use garden:references
rails g model Plant garden:references name image_url
rails db:migrate
```

Let's add some simple validations also in `plant.rb`:

```ruby
# File: app/models/plant.rb

class Plant < ApplicationRecord
  validates :name, presence: true
  validates :image_url, presence: true
end
```

### Associate gardens and plants

The `belongs_to :garden` association was automatically added to the `Plant` model when the model was created (thanks to the `garden:references` attribute!). This way, we can now write `plant.garden` to get the garden associated to a plant.

But what if we want to get all the plants associated to a garden? We need to add the `has_many :plants` association to the `Garden` model! To make sure that the plants of a garden are deleted when the garden is deleted, we can add the `dependent: :destroy` option to the association:

```ruby
# File: app/models/garden.rb

class Garden < ApplicationRecord
  has_many :plants, dependent: :destroy
  # [...]
end
```

### Add a plant to a garden

We want to display all the plants on the garden‚Äôs show page and have a form to add a new one.

Let‚Äôs first take care of the form! Instantiate a plant in the `GardensController#show` action:

```ruby
# File: app/controllers/gardens_controller.rb

class GardensController < ApplicationController
  # [...]
  def show
    @plant = Plant.new
  end
  # [...]
end
```

And display the form in the view after the banner:

```erb
<!-- app/views/gardens/show.html.erb -->
<!-- [...] -->

<div class="container my-3">
  <div class="row justify-content-center">
    <div class="col-4">
      <h4>Add a plant:</h4>
      <%= simple_form_for [@garden, @plant] do |f| %>
        <%= f.input :name, placeholder: "Palm tree" %>
        <%= f.input :image_url, placeholder: "Insert an image URL" %>
        <%= f.submit "Add", class: "btn btn-primary" %>
      <% end %>
    </div>
  </div>
</div>
```

This will raise an error as `simple_form_for [@garden, @plant]` calculates the form tag‚Äôs action attribute with Rails‚Äô `garden_plants_path(@garden)` route helper. This helper generates the path `/gardens/:garden_id/plants` using a POST method.

So, let‚Äôs add this route! The route should be nested in the garden‚Äôs resources as we want to create a plant associated to a garden. We only need the create action, so we can use the `only` option:

```bash
# File: config/routes.rb

Rails.application.routes.draw do
  # [...]
  resources :gardens do
    resources :plants, only: [:create]
  end
end
```

This will create the `garden_plants_path` helper that will be used by the form. This route points to the `PlantsController#create` action. Let‚Äôs first create the controller:

```bash
rails g controller Plants
```

And add the create action:

```ruby
# File: app/controllers/plants_controller.rb

class PlantsController < ApplicationController
  def create
    # 1. Initialize a new plant with the params coming from the form
    @plant = Plant.new(plant_params)
    # 2. Find the garden using the garden_id param coming from the url
    @garden = Garden.find(params[:garden_id])
    # 3. Associate the plant to the garden
    @plant.garden = @garden
    # 4. Save the plant
    @plant.save

    # Redirect to the garden show page
    redirect_to garden_path(@garden)
  end

  private

  def plant_params
    params.require(:plant).permit(:name, :image_url)
  end
end
```

Now, let's update the show view to display the plants in a grid! 

To get the plants associated with a garden, we can use the `@garden.plants` association. Let‚Äôs iterate over the plants and display them in a grid after the banner and before the form:

```erb
<!-- File: app/views/gardens/show.html.erb -->

<!-- [...] -->
<div class="cards my-3">
  <% @garden.plants.each do |plant| %>
    <div class="card-category" style="background-image: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3)), url('<%= plant.image_url %>')">
      <%= plant.name %>
    </div>
  <% end %>
</div>
<!-- [...] -->
```

Create a CSS file for the card component and insert the CSS from the UI kit:

```bash
# Create a new file for the card component
touch app/assets/stylesheets/components/_card.css
```

```css
/* File: app/assets/stylesheets/components/_card.css */

.cards {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-gap: 16px;
}

.card-category {
  background-size: cover;
  background-position: center;
  height: 180px;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size: 24px;
  font-weight: bold;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
  border-radius: 5px;
  box-shadow: 0 0 15px rgba(0,0,0,0.2);
}
```

### Remove a plant

Let‚Äôs now add a user story to make the plants destroyable. 

To destroy a plant, we need to add a new route:

```ruby
# File: config/routes.rb

Rails.application.routes.draw do
  # [...]
  resources :gardens do
    resources :plants, only: [:create, :destroy]
  end
end
```

By running `rails routes`, we can see that this route points to the `PlantsController#destroy` action. Let‚Äôs add it:

```ruby
# File: app/controllers/plants_controller.rb

class PlantsController < ApplicationController
  # [...]
  def destroy
    # 1. Find the plant using the :id param coming from the url
    @plant = Plant.find(params[:id])
    # 2. Destroy the plant
    @plant.destroy

    # Redirect to the garden show page
    redirect_to garden_path(@plant.garden)
  end
  # [...]
end
```

The interface shouldn‚Äôt be too complex - you can update the `show.html.erb` view and use this markup for the link:

```erb
<!-- File: app/views/gardens/show.html.erb -->

<div class="card-category" style="background-image: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3)), url('<%= plant.image_url %>')">
  <%= plant.name %>
  <%= link_to "+", garden_plant_path(plant), data: { turbo_method: :delete, turbo_confirm: "Are you sure?" }, class: "card-remove-link" %>
</div>
```

For the CSS, you can use the following:

```css
/* File: app/assets/stylesheets/components/_card.css */

/* [...] */

.card-category {
  /* [...] */
  position: relative;
}

.card-remove-link {
  color: white;
  border-radius: 50%;
  border: 1px solid white;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 30px;
  width: 30px;
  position: absolute;
  right: 10px;
  top: 10px;
  opacity: 0.8;
  transform: rotate(45deg);
  font-weight: lighter;
}

.card-remove-link:hover {
  color: white;
  text-decoration: none;
  opacity: 1;
}
```

### Clenups

We should now get rid of the scaffolded code that we don‚Äôt need anymore. 

Since we only use the `index` and `show` actions for gardens, we can update our router to only keep these two routes:

```ruby
# File: config/routes.rb

Rails.application.routes.draw do
  # [...]
  resources :gardens, only: [:index, :show] do
    resources :plants, only: [:create, :destroy]
  end
end
```

In the `GardensController`, we can remove the actions we don‚Äôt use anymore: `new`, `edit`, `create`, `update`, and `destroy`.

Also, since we won't need the views for these actions, we can delete the `new.html.erb`, `edit.html.erb` and `_form.html.erb` files in the `app/views/gardens` folder.

Finally, we can remove the "New garden" link from the `index.html.erb` view and simplify the `_garden.html.erb` partial to only display the name of a garden.

## Conclusions

- **Using a scaffold is generally not a good idea** as it generates a lot of code that you don‚Äôt need and that you will have to clean up later.
- **When creating a model, always think about the associations it will have with other models** (draw a schema if it helps!). The associations can be specified using `belongs_to` and `has_many`. Use the `dependent: :destroy` option if you want the associated models to be destroyed when the main model is destroyed.
- **Only use the routes and views you actually need!** In this application, we wanted to display, create and destroy plants from **within** a garden page, so we only needed the `show` action for a garden as everything is happening inside that page. The plants only need a `create` and `destroy` action to be manipulated (not viewed!), so we don‚Äôt need the `index` and `show` actions.
